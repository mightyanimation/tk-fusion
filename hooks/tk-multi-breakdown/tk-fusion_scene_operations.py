# Copyright (c) 2013 Shotgun Software Inc.
#
# CONFIDENTIAL AND PROPRIETARY
#
# This work is provided "AS IS" and subject to the Shotgun Pipeline Toolkit
# Source Code License included in this distribution package. See LICENSE.
# By accessing, using, copying or modifying this work you indicate your
# agreement to the Shotgun Pipeline Toolkit Source Code License. All rights
# not expressly granted therein are reserved by Shotgun Software Inc.

from tank import Hook
import os
import re

import BlackmagicFusion as bmd
fusion = bmd.scriptapp("Fusion")


class BreakdownSceneOperations(Hook):
    """
    Breakdown operations for Natron.

    This implementation handles detection of natron read and write nodes.
    """

    def scan_scene(self):
        """
        The scan scene method is executed once at startup and its purpose is
        to analyze the current scene and return a list of references that are
        to be potentially operated on.

        The return data structure is a list of dictionaries. Each scene 
        reference that is returned should be represented by a dictionary with 
        three keys:

        - "attr": The filename attribute of the 'node' that is to be operated
           on. Most DCCs have a concept of a node, attribute, path or some
           other way to address a particular object in the scene.
        - "type": The object type that this is. This is later passed to the
           update method so that it knows how to handle the object.
        - "path": Path on disk to the referenced object.

        Toolkit will scan the list of items, see if any of the objects matches
        any templates and try to determine if there is a more recent version
        available. Any such versions are then displayed in the UI as out of 
        date.
        """

        engine = self.parent.engine
        
        # Introspect the natron scene for read and write nodes
        # so we can gather the filenames available.
        refs = []
        
        comp = fusion.GetCurrentComp()
        engine.log_debug("Scene operation: getting current comp")
        comp.Lock()
        engine.log_debug("Scene operation: lock current comp")
        for tool in comp.GetToolList(False, "Loader").values():
            ref_path = tool.GetAttrs("TOOLST_Clip_Name").values()
            if ref_path:
                engine.log_debug("Scanning node {}: {}".format(tool.GetAttrs("TOOLS_Name"), ref_path[0]))
                ref_path[0].replace("/", os.path.sep)
                refs.append({"node": tool.GetAttrs("TOOLS_Name"), "type": "file", "path": ref_path[0]})

        engine.log_debug("Scene operation: unlock current comp")
        comp.Unlock()

        return refs

    def update(self, items):
        """
        Perform replacements given a number of scene items passed from the app.

        Once a selection has been performed in the main UI and the user clicks
        the update button, this method is called.

        The items parameter is a list of dictionaries on the same form as was
        generated by the scan_scene hook above. The path key now holds
        the that each attribute should be updated *to* rather than the current
        path.
        """
        comp = fusion.GetCurrentComp()
        engine = self.parent.engine

        loaders = {}
        for x in comp.GetToolList(False, "Loader").values():
            loaders[x.GetAttrs("TOOLS_Name")] = x

        for i in items:
            engine.log_debug(
                    "File Updating to version %s" % i)
 
            node = i["node"]
            node_type = i["type"]
            new_path = i["path"]
            
            if node_type == "file":
                loader = loaders[node]
                if loader:
                    engine.log_debug(
                        "File %s: Updating to version %s" % (node, new_path))
                    comp.Lock()
                    globalIn = int(loader.GlobalIn[comp.CurrentTime])
                    globalOut = int(loader.GlobalIn[comp.CurrentTime])
                    trimIn = int(loader.ClipTimeStart[comp.CurrentTime])
                    trimOut = int(loader.ClipTimeEnd[comp.CurrentTime])
                    new_path = re.sub(r'%(\d+)d', str(globalIn), new_path)
                    loader.Clip = new_path
                    loader.GlobalIn = globalIn
                    loader.GlobalOut = globalOut
                    loader.ClipTimeStart = trimIn
                    loader.ClipTimeEnd = trimOut              
                    comp.Unlock()
